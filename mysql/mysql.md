## 高性能MySQL

### 一. MySQL 逻辑架构

![MySql服务器逻辑架构图](E:\git-markdown\markdown\images\MySql\MySql服务器逻辑架构图.png)



### 二. 锁粒度

#### 表锁（table lock）

​		表锁是MySQL中最基本的锁策略，并且是开销最小的锁。它会锁定整张表，一个用户在对表进行（插入、删除、更新）等操作前，需要先获得锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得锁，读锁之间是不相互阻塞的。



#### 行级锁  (row lock)

​		行级锁可以最大程度的支持并发处理（同时也带来了最大的锁开销）。行级锁只在存储引擎层实现。而MySQL服务器层没有实现。服务器层完全不了解存储引擎中的锁实现



### 三. 事务

​		就像锁粒度的升级会增加系统开销一样，这种事务处理过程中额外的安全性，也会需要数据库系统坐更多的额外工作。一个实现了ACID的数据库，相比没有实现ACID的数据库，通常需要更强的CPU处理能力、更大的内存和更多的磁盘空间

#### 1. 事务的ACID特性

##### 原子性 (Atomicity)

​		一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

##### 一致性 (Consistency)

​		数据库总是从一个一致性的状态转换到另一个一致性的状态。

##### 隔离性 (Isolation)

​		通查来说，一个事务所作的修改在最终提交以前，对其他事务是不可见的。

##### 持久性 (Durability)

​		一旦事务提交，则其所做的修改就会永久保存的数据库中。此时即使系统崩溃，修改的数据也不会丢失。



#### 2. 隔离级别

​		隔离性比想象得要负责，在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所作得修改，哪些事务内和事务间是可见得，哪些是不可见的。较低级别的隔离通查可以执行更高的并发，系统的开销也更低。（每种存储引擎实现的隔离级别不尽相同）。下面简单介绍以下四种隔离级别。

##### 未提交读 (READ UNCOMMITTED)

​		在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的，事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。这个界别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他的级别好太多，但却缺乏其他界别的很多好处，在实际应用中一般很少使用。

##### 提交读 (READ COMMITTED)

​		在READ UNCOMMITTED级别中，一个事务开始时，只能看见已经提交的事务所作的修改。换句话说，一个事务从开始知道提交之前，所作的任何修改其他的事务都是不可见的。这个界别有时候也叫做不可重复读（nonrepeatableread）,因为两次执行统一的查询，可能会得到不同的结果。大多数数据库系统的默认级别是这个，但MySQL不是

##### 可重复读 (REPEATABLE READ)

​		REPEATABLE READ解决了脏读的问题。该级别保证了在同一个事务中多次读取统一记录的结果是一直的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，会产生幻行（Phantom Row)。在InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题。可重复读时MySQL的默认事务隔离级别

##### 可串行化 (SERIALIZABLE)

​		SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加速，所以可能导致大量的超时和锁争用的问题。实际应用也很少用的这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。



![SQL隔离级别](E:\git-markdown\markdown\images\MySql\SQL隔离级别.png)

* 不可重复读和幻读到底有什么区别？

  ​	(1) 不可重复读是读取了其他事务更改的数据，**针对update操作**

  解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

  ​	(2) 幻读是读取了其他事务新增的数据，**针对insert和delete操作**

  解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。



#### 死锁

​		当多个事务试图以不同的顺序锁定资源时，就有可能产生死锁。多个事务的同时锁定同一个资源时，也会产生死锁。

​		为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如InnoDB存储引擎，越能监测到死锁的循环依赖，并立即返回一个错误。InnoDB目前处理死锁的方法时，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）




















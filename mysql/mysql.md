## 高性能MySQL

### 一. MySQL 逻辑架构

![MySql服务器逻辑架构图](E:\git-markdown\markdown\images\MySql\MySql服务器逻辑架构图.png)



### 二. 锁粒度

#### 表锁（table lock）

​		表锁是MySQL中最基本的锁策略，并且是开销最小的锁。它会锁定整张表，一个用户在对表进行（插入、删除、更新）等操作前，需要先获得锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得锁，读锁之间是不相互阻塞的。



#### 行级锁  (row lock)

​		行级锁可以最大程度的支持并发处理（同时也带来了最大的锁开销）。行级锁只在存储引擎层实现。而MySQL服务器层没有实现。服务器层完全不了解存储引擎中的锁实现



### 三. 事务

​		就像锁粒度的升级会增加系统开销一样，这种事务处理过程中额外的安全性，也会需要数据库系统坐更多的额外工作。一个实现了ACID的数据库，相比没有实现ACID的数据库，通常需要更强的CPU处理能力、更大的内存和更多的磁盘空间

#### 1. 事务的ACID特性

##### 原子性 (Atomicity)

​		一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

##### 一致性 (Consistency)

​		数据库总是从一个一致性的状态转换到另一个一致性的状态。

##### 隔离性 (Isolation)

​		通查来说，一个事务所作的修改在最终提交以前，对其他事务是不可见的。

##### 持久性 (Durability)

​		一旦事务提交，则其所做的修改就会永久保存的数据库中。此时即使系统崩溃，修改的数据也不会丢失。



#### 2. 隔离级别

​		隔离性比想象得要负责，在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所作得修改，哪些事务内和事务间是可见得，哪些是不可见的。较低级别的隔离通查可以执行更高的并发，系统的开销也更低。（每种存储引擎实现的隔离级别不尽相同）。下面简单介绍以下四种隔离级别。

##### 未提交读 (READ UNCOMMITTED)

​		在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的，事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。这个界别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他的级别好太多，但却缺乏其他界别的很多好处，在实际应用中一般很少使用。

##### 提交读 (READ COMMITTED)

​		在READ UNCOMMITTED级别中，一个事务开始时，只能看见已经提交的事务所作的修改。换句话说，一个事务从开始知道提交之前，所作的任何修改其他的事务都是不可见的。这个界别有时候也叫做不可重复读（nonrepeatableread）,因为两次执行统一的查询，可能会得到不同的结果。大多数数据库系统的默认级别是这个，但MySQL不是

##### 可重复读 (REPEATABLE READ)

​		REPEATABLE READ解决了脏读的问题。该级别保证了在同一个事务中多次读取统一记录的结果是一直的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，会产生幻行（Phantom Row)。在InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题。可重复读是MySQL的默认事务隔离级别

##### 可串行化 (SERIALIZABLE)

​		SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加速，所以可能导致大量的超时和锁争用的问题。实际应用也很少用的这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。



![SQL隔离级别](E:\git-markdown\markdown\images\MySql\SQL隔离级别.png)

* 几个概念：

  脏读：可以读取未提交的数据。RC 要求解决脏读；

  不可重复读：同一个事务中多次执行同一个select, 读取到的数据发生了改变(被其它事务update并且提交)；

  可重复读：同一个事务中多次执行同一个select, 读取到的数据没有发生改变(一般使用MVCC实现)；RR各级级别要求达到可重复读的标准；

  幻读：同一个事务中多次执行同一个select, 读取到的数据行发生改变。也就是行数减少或者增加了(被其它事务delete/insert并且提交)。SERIALIZABLE要求解决幻读问题；

  

* 不可重复读和幻读到底有什么区别？

  ​	(1) 不可重复读是读取了其他事务更改的数据，**针对update操作**

  解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

  ​	(2) 幻读是读取了其他事务新增的数据，**针对insert和delete操作**

  解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。



#### 3.死锁

​		当多个事务试图以不同的顺序锁定资源时，就有可能产生死锁。多个事务的同时锁定同一个资源时，也会产生死锁。

​		为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如InnoDB存储引擎，越能监测到死锁的循环依赖，并立即返回一个错误。InnoDB目前处理死锁的方法时，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）



### 四. MySQL的存储引擎

​		创建表时，MySQL会在数据库子目录下创建一个和表同名的`.frm`文件保存表的定义。因为MySQL使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台密切相关。在windows中，大小写时不敏感的；而在类Unix中则是敏感的。不同的存储引擎保存数据和所以的方式是不同的，但表的定义则是在MySQL服务处统一处理的。

#### 1. InnoDB存储引擎

​		InnoDB的数据存储在表空间中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。

​		InnoDB是MySQL的默认事务型引擎。它被设计用来处理大量的短期事务，短期事务大部分情况是正常提交的，很少会被回滚。InnoDB的性能和自动崩溃恢复特性，是的它在非事务型存储的需求中也很流行。除非有非常特别的原因需要使用其他的存储引擎，否则应该游戏考虑InnoDB引擎。

​		InnoDB采用MVCC来支持高并发。并且实现了四个标准的隔离级别。其默认级别是REPEATABLE READ（可重复读）。并且通过间隙锁策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询设计的行，还会对所有中的间隙进行锁定，以防止幻影行插入。

​		InnoDB表是基于聚簇索引建立的。聚簇索引对主键查询有很高的性能。

#### 2. MyISAM存储引擎

​		在MySQL5.1之前的版本，MyISAM是默认的存储引擎。MyISAM提供了大量的特性包括全文所以，压缩，空间函数（GIS）等，但**MyISAM不支持事务和行级锁**，而且有一个缺陷是崩溃后无法安全恢复。

* 存储

  ​	MyISAM会将表存储在两个文件中：数据文件和索引文件，分别以.MYD和.MYI为扩展名。

* 特性

  ​	加锁与并发：MyISAM对整张表加锁而不是针对行。

  ​	修复：对于MyISAM表，MySQL可以手工或者自动执行监测和修复操作，执行表的修复可能导致一些数据丢失，而且修复操作时是非常慢的。

  ​	索引特性：对于MyISAM表，即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引，MyISAM也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。





[MySQL索引底层：B+树详解](https://mp.weixin.qq.com/s/FXOEq-T7pDSlbwccW_2l_w)

[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)




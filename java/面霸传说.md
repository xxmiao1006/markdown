## 题目

### java

**1.String、StringBuffer 和 StringBuilder 的区别?**

​		String 不可变，StringBuffer 和 StringBuilder 可变

​		StringBuffer和StringBulider都是用来拼接字符串的，StringBulider不是线程安全的，StringBuffer是线程安全的（StringBuffer对操作方法都加上了synchronize关键字）。



**2.String 的内部实现?String 对象主要存储在哪块区域?**

​		JDK8 中内部实现实际上是一个char[] 数组。value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。

```java
//数组定义为常量，不可修改 
private final char value[];
```

​		在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 `coder` 来标识使用了哪种编码

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final byte[] value;

    /** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
}
```

​		在JDK1.7之前，StringPool被放在运行时常量池，所以属于永久代，在1.7之后被移到了堆中，因为永久代空间有限，容易引发OOM。



**3.String为什么要声明成final类？（不可变的好处？）**

* 可以缓存 hash 值

因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。

* String Pool 的需要

如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191210004132894.png"/> </div><br>

* 安全性

String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。

* 线程安全  

String 不可变性天生具备线程安全，可以在多个线程中安全地使用。



**4.HashMap 和 HashSet 的区别？HashSet是怎么实现的？**

HashMap最顶层实现的是Map接口，HashSet最顶层实现的是Collection接口；Map接口一般存放的是键值对，而Collection接口存放的是单一元素；HashMap是用键来计算hash值判断元素是否重复，HashSet使用值对象来计算hash值

HashSet的底层实际就是使用的HashMap,将值对象当作HashMap的key（不可重复），值对象为同一对象。

```java
public class HashSet<E>
    extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable
{

    private transient HashMap<E,Object> map;

    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();
    
    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
```



**5.HashMap、HashTable 和 ConcurrentHashMap 的区别**

HashMap是线程不安全的，HashTable(Synchronized)和ConcurrentHashMap(1.8之前使用分段锁，1.8并发控制使用Synchronized和CAS来操作) 是线程安全的

HashMap和ConcurrentHashMap是Map接口的实现，HashTable是基于Dictionary抽象类

HashMap允许空（null）键值（key）而Hashtable、ConcurrentHashMap 不允许



**6.创建对象的过程**

* 检查类是否被加载
* 为对象分配内存（**类加载完成以后**，虚**拟机就开始为对象分配内存**，此时所需内存的**大小就已经确定**了。只需要在堆上分配所需要的内存即可）
* 为分配的内存空间初始化零值（将对象的内存空间都初**始化为零值**，这样能**保证对象即使没有赋初值，也可以直接使用**）
* 对对象进行其他的设置（**设置的地方都在对象头中**，包括这个**对象所属的类，类的元数据信息，对象的hashcode，GC分代年龄**等信息）
* 执行init方法

创建对象的几种方式：

* 使用new关键字

* Class对象的newInstance()方法

* 构造函数对象的newInstance()方法

* 对象反序列化

* Object对象的clone()方法
* 使用Unsafe类创建对象

在创建对象的过程中，jvm会首先去元空间检查是否有这个类的信息，如果没有则执行类的加载过程，有的话则创建对象。

对象的创建过程中，（**在为这些实例变量分配内存的同时，这些实例变量也会被赋予默认值(零值)。**）初始化顺序：

父类静态变量/父类静态方法块-> 子类静态变量/子类静态代码块->父类成员变量/方法块->父类构造函数->子类成员变量/方法快->子类构造函数

小结：创建一个对象包含下面两个过程：

1、类构造器完成类初始化（分配内存、赋予默认值）

2、类实例化（赋予给定值）

[Java 中创建一个对象的过程？](https://www.cnblogs.com/JonaLin/p/12674281.html)



**7.判断一个对象是否被回收**

判断对象是否被回收一般有两种算法，引用技术法和可达性分析算法，引用计数法无法解决对象循环引用的问题，因此java里面判断对象是否能被回收采用的是可达性分析算法。

可达性分析算法:以GC Roots为起点，可达的都是存活的，不可达的都是需要被回收的。在java中能作为GC Roots的一般是：

- 虚拟机栈中局部变量表中引用的对象
- 本地方法栈中 JNI 中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象



**8.新生代和老年代用的垃圾回收策略？**

垃圾回收策略一般有一下几种：标记-清除（标记和清除过程效率都不高，而且会产生内存碎片），标记-整理（需要移动大对象，但是不会产生内存碎片），复制-清除（内存使用率低）。所以一般而言针对不同代采用不同的算法。

- 新生代使用：复制算法
- 老年代使用：标记 - 清除 或者 标记 - 整理 算法



**9.强引用、弱引用、软引用和虚引用的区别**

被强引用关联的对象不会被回收。

被软引用关联的对象只有在内存不够的情况下才会被回收。

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

虚引用又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。



**10.final 关键字的作用，final 在多线程并发条件下的作用**

- 对于基本类型，final 使数值不变；
- 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。
- 声明方法不能被子类重写。
- 声明类不允许被继承。

final 在多线程并发条件下的作用原理是通过禁止cpu的指令集重排序

1. 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
2. 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。

在Java语言里面（特指JDK 5以后，即Java内存模型被修正之后的Java语言），不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。

多线程共享的数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行

[多线程与高并发(五)final关键字](https://www.cnblogs.com/yuanqinnan/p/11231274.html)



### 操作系统

**1.线程的生命周期**

线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。

- 新建：就是刚使用new方法，new出来的线程；
- 就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;
- 运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;
- 阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;
- 销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;



**2.sleep和wait的区别**

sleep是属于Thread类的**静态**方法，而wait是Object类的**实例**方法；

sleep,wait调用后都会暂停当前线程并让出cpu的执行时间，但不同的是sleep不会释放当前持有的对象的锁资源，到时间后会继续执行，而wait会放弃所有锁并需要notify/notifyAll后重新获取到对象锁资源后才能继续执行

它们都可以被interrupted方法中断。

另外值得一提的是Thread.Sleep(0)的作用，就是触发操作系统立刻重新进行一次CPU竞争，竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权



**3.死锁产生的原因**

* 因为系统资源不足。
* 进程运行推进的顺序不合适。
* 资源分配不当等。

产生死锁的四个必要条件：

* 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
* 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
* 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
* 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

预防死锁

* 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
* 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏保持条件）
* 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
* 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）
  



### 计算机网络

**1.浏览器中输入域名（url）后发生了什么？**

[键入网址后，期间发生了什么？](https://mp.weixin.qq.com/s/I6BLwbIpfGEJnxjDcPXc1A)

* 解析url，通过DNS解析（DNS解析用的UDP协议）域名成ip地址
* 根据该 IP 地址和默认端口 80，建立TCP连接，3次握手
* 发送http请求
* 服务器处理请求
* 返回http响应
* 关闭TCP连接
* 浏览器解析渲染页面
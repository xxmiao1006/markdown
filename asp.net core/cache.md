## cache

### 一. 缓存击穿

一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value ，就应该去后端系统查找（比如数据库）。如果 key 对应的 value 是一定不存在的，并且对该 key 并发请求量很大，就会对后端系统就会造成很大的压力。

在高并发下,多线程同时查询同一个资源,如果缓存中没有这个资源,那么这些线程都会去后端服务或数据库查找,对数据库造成极大压力,缓存也就失去存在的意义。

**缓存击穿解决方案**

导致缓存击穿的问题在于高并发多线程情景下，许多请求一下子都到后端服务和数据库，导致后端服务与数据库的压力骤增。

处理这个问题，在多线程请求同一个 key 的时候，进行排队，这样第一次请求后端服务和数据库之后更新缓存的值，下一个请求从缓存中取数据的时候就会拿到缓存数据，不会再请求后端服务和数据库。

### 二. 缓存穿透

缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库中查询，从而失去了缓存的意义而且相比直接查询数据库还增加了每次都去查缓存。

**缓存穿透解决方案**

导致问题出现的原因在于请求一个不存在的数据从而使得缓存始终不存在进而导致后端系统（主要是数据库）要承受很大的压力，所以想要解决这个问题，就势必就在缓存这里拦截住大量的请求，使得最终走到后端系统，查询数据库的请求尽可能的少。

一般处理这个问题，缓存不存在的时候会在缓存中设置一个时间较短的内容为空的缓存，从而减少实际请求到后端和进行数据库查询的次数。

复杂一些的解决方案有 布隆过滤器，基本原理是设置一个 list，查询缓存的时候从 list 里进行判断

> 布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难 如果想要判断一个元素是不是在一个集合里，一般想到的是将所有元素保存起来，然后通过比较确定。链表，树等等数据结构都是这种思路. 但是随着集合中元素的增加，我们需要的存储空间越来越大，检索速度也越来越慢(O(n),O(logn))。不过世界上还有一种叫作散列表（又叫哈希表，Hash table）的数据结构。它可以通过一个Hash函数将一个元素映射成一个位阵列（Bit array）中的一个点。这样一来，我们只要看看这个点是不是1就可以知道集合中有没有它了。这就是布隆过滤器的基本思想。

### 三. 缓存雪崩

当缓存服务器重启或者大量缓存集中在某一个时间失效，这样在失效的时候，也会给后端系统和数据库带来很大压力。

**缓存雪崩解决方案**

导致出现缓存雪崩的根本原因在于缓存大量失效，从而导致大量请求没有命中缓存，大量请求走到后端服务和数据库，造成压力。

如果系统启动就依赖很多缓存，那可以通过其它服务进行缓存预热，提前把需要的数据放到缓存中，避免系统启动大量请求直接请求到后端服务和数据库。

既然是由于同一时间缓存大量失效，我们也可以着手从缓存的失效时间上，做一些优化，让缓存不要在同一时间点失效。具体的实施办法，你可以在设置失效时间的时候随机加几秒过期时间，避免同一时间点缓存大量失效。
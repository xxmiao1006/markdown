## .net 对象生命周期

### 一. 不用程序员操心的堆 — 托管堆

程序在计算机上跑着，就难免会占用内存资源来存储在程序运行过程中的数据，我们按照内存资源的存取方式将内存划分为**堆内存**和**栈内存**。

**栈内存，**通常使用的场景是：**对存取速度要求较高且数据量不大**

典型的栈内存使用的例子就是函数栈，每一个函数被调用时都会被分配一块内存，这块内存被称为栈内存，以先进后出的方式存取数据，在函数执行过程中不断往函数栈中压入（PUSH）数据（值类型数据：int、float、对象的引用...），函数执行完后又将函数栈中的数据逐个弹出（POP）,由于是以操作栈的形式来存取，所以访问速度快。

![object-1.png](https://ws1.sinaimg.cn/large/0072fULUgy1g9sj463kfqj30l50dut8x.jpg)

**堆内存，**从字面意思上理解就好像是仓库里面可以存一堆破烂，你若是需要存点什么东西就尽管往里面一扔，仓库里有的是空间。事实确实也是如此，**堆内存中可以存放大规格的数据（比如对象资源）**，这些数据是不适合存放在栈中的，因为栈空间的容量有限，这就是**堆内存相对于栈内存的好处：容量大**。但是它的缺点也是显而易见的，那就是**存取堆内存的数据相较于存取栈内存是非常慢的**，试想一下，让你在仓库里的一堆破烂里去找你想要的东西是什么感觉。 [栈内存比堆内存详细参考](https://blog.csdn.net/boyxiaolong/article/details/8543676)

![object-2.png](https://ws1.sinaimg.cn/large/0072fULUgy1g9sj4dw45hj30hu0asaa6.jpg)

从内存分配方式上看，堆内存不同于栈内存，函数栈是在每一个函数被执行的时候被自动分配并且函数执行完成后自动回收，而如果你想使用堆内存，就得自己动手丰衣足食

在.NET的世界，使用new关键字创建一个对象，首先对象资源被分配在托管堆中，然后new会返回一个指向堆上对象的引用，而不是真正的对象本身。如果在方法作用域中将引用变量声明为本地变量，这个引用变量保存在栈内，以供应用程序以后使用。

托管堆，顾名思义，就是托给别人管的堆，**那么是谁在管理着这个堆上的对象资源呢**？

**答案是**：**CLR(Common Lanauage Runtime)，对象的实例化结束以后，GC(垃圾回收器)将会在对象不再需要时将其销毁。**

也就是说，通过允许垃圾收集器负责销毁对象，内存管理的麻烦就都交给CLR了，万事大吉。

看似问题好像都已水落石出，无非就是将堆内存资源回收交给了CLR去承担。难道你就不想知道的更多一点？比如接着而来的问题：

​		**1**、**垃圾回收器如何判断一个对象什么时候不再需要？**

　　**2、垃圾回收器又在什么时候会执行垃圾清理的操作？**

------

### 二. **CIL的new指令 — 垃圾回收的触发者**

c#中的**new关键字最终会被编译器翻译成CIL的newobj指令**。

![object-3.png](https://ws1.sinaimg.cn/large/0072fULUgy1g9sjdbrembj30g805nwef.jpg)

首先，需要明白托管堆不仅仅是一个可由CLR访问的随机内存块。.NET垃圾回收器是堆的“清洁工”，出于优化的目的它会压缩空闲的内存块（当需要时）。为了辅助压缩，托管堆会维护一个指针(通常被叫做下一个对象指针或者是新对象指针），这个指针用来标识下一个对象在堆中分配的地址

此外，newobj指令通知CLR来执行下列的核心任务：

　　**(1)计算要分配的对象所需的全部内存（包括这个类型的数据成员和类型的基类所需的内存）。**

　　**(2)检查托管堆来确保有足够的空间来放置所申请的对象。如果有足够的空间，会调用这个类型的构造函数，构造函数会返回一个指向内存中这个新对象的引用，这个新对象的地址刚好就是下一个对象指针上一次所指向的位置。**

　　**(3)最后，在把引用返回给调用者之前，让下一个对象指针指向托管堆中下一个可用的位置。**

下面的图解释了在托管堆上分配对象的细节。

![object-4.png](https://ws1.sinaimg.cn/large/0072fULUgy1g9sji6p044j30ev05g3yj.jpg)

在c#中分配对象是一个很频繁的操作，照这样下去托管堆上的空间迟早会被挥霍完，所以，重点来了，**如果CLR 发现托管堆没有足够空间分配请求的类型时，它会执行一次垃圾回收来释放内存**。

当执行垃圾回收时，垃圾收集器临时挂起当前进程中的所有的活动线程来保证在回收过程中应用程序不会访问到堆。（一个线程是一个正在执行的程序中的执行路径）。一旦垃圾回收完成，挂起的线程又可以继续执行了。还好，.NET 垃圾回收器是高度优化过的，所以用户很少能察觉到应用程序中的短暂中断。

通过对CIL的new指令作用的解读，我们知道了:**如果托管堆没有足够的空间分配一个请求的对象，则会执行一次垃圾回收**。

------

### 三. **应用程序根的 — 区分不可到达的对象**

现在让我们来讨论一下垃圾回收器怎样确定什么时候“**不再需要**”一个对象。为了理解细节，你需要知道应用程序根的概念。

简单来说，一个根是一个引用，这个引用指向堆上面的一个对象的。严格来说，一个根可以有以下几种情况：

　   **(1) 指向全局对象的引用（尽管C#不支持，但CIL代码允许分配全局对象）**

　　**(2) 指向任何静态对象**

　　**(3) 指向一个应用程序代码中的局部对象**

　　**(4) 指向传入到一个函数中的对象参数**

　　**(5) 指向等待被终结(finalized)的对象**

　　**(6) 任何一个指向对象的CPU寄存器**

在一次垃圾回收的过程中，运行环境会检查托管堆上面的对象是否仍然是从应用程序根可到达的。为了检查可达，CLR会建立一个代表堆上每个可达对象的图。对象图用来记录所有可达的对象。同时，注意垃圾回收器绝不会在图上标记一个对象两次，因此避免了烦人的循环引用。

假设托管堆上有名字为A,B,C,D,E，F和G的对象集合。在一次垃圾回收过程中，会检查这些对象（同时包括这些对象可能包含的内部对象引用）是否是根可达的。一旦图被建立起来，不可达的对象（在此是对象C和F）被标记为垃圾。

下图是上述场景的一个可能的对象图（你可以把箭头读作依赖或者需要，例如"E依赖于G，间接依赖于B，“A不依赖任何对象”等）。

![object-5.png](https://ws1.sinaimg.cn/large/0072fULUgy1g9sjqcfsxrj30ac06jjrh.jpg)

​											（创建的对象图是用来决定哪些对象是应用程序根可达的。）

　　一旦一个对象已经被标记为终结（此例子中是C和F--在图中没有他俩），它在内存中就被清理掉了。在此时，堆上的剩余内存空间被压缩，这会导致CLR修改活动的应用程序根集合（和对应的指针）来指向正确的内存位置（这个操作是自动透明的）。最后，调整下一个对象指针来指向下一个可用的内存位置。

下图阐明了清除和压缩堆的过程。

![object-6.png](https://ws1.sinaimg.cn/large/0072fULUgy1g9sjv1jz3zj308e03gdfq.jpg)

　**到这里，通过对应用程序根的作用的理解，我们知道了如何知道一个对象是“不再需要”的。通俗点来说就是，这个对象在应用程序中已经无需被访问了，成为了一座“孤岛”，自然也就不再需要它了。**

------

### 四. **理解对象的代 — 垃圾回收过程的优化**

在尝试找到不可达的对象时，CLR并不是检查托管堆上的每个对象。很明显，这样做会消耗大量时间，尤其在大型（例如现实中）程序中。

为了帮助优化这个过程，堆上的每个对象被分配到一个特殊的"代”。代这个概念背后的想法很简单：**对象在堆上存活的时间越长，接下来它继续存在的可能性也就越大，即较旧的对象生存期长，较新的对象生存期短**。例如，实现Main()的对象一直在内存中，直到程序结束。相反，最近才被放到堆中的对象（例如在一个函数范围里分配的对象）很可能很快就不可达。在堆上的每个对象属于以下的某一个代：


　   **Generation 0：标识一个最近分配的还没有被标记为回收的对象**

　　**Generation 1: 标识一个经历了一次垃圾回收而存活下来的对象（例如，他被标记为回收，但由于堆空间够用而没有被清除掉）**

　　**Generation 2:标识一个经历了不止一轮垃圾回收而存活下来的对象。**

垃圾回收器首先会检查generation 0的所有对象。如果标记并清理这些对象（译者注：因为新对象的生存期往往较短，并且期望在执行回收时，应用程序不再使用第 0 级托管堆中的许多对象）后产生了足够使用的内存空间，任何存活下来的对象就被提升到Generation 1。为了理解一个对象的代如何影响回收的过程，可以查看下图。下图解释了generation 0中一次垃圾回收后，存活的对象被提升的过程。

![object-7.png](https://ws1.sinaimg.cn/large/0072fULUgy1g9sjzscmqfj308g05ijra.jpg)

​												（generation 0 中的存活对象被提升到generation 1）

　　如果所有的generation 0对象都被检查了，但是产生的内存空间仍然不够用，就检查一遍generation 1中的所有对象的可达性并回收。存活下来的generation 1对象被提升到generation 2。如果垃圾回收器仍然需要额外的内存，generation 2的对象就经历检查并被回收。此时，如果一个generation 2的对象存活下来，它仍然是一个generation 2的对象。

其实通过**对象的代的设计是想达到这么一个效果:新对象（比如局部变量）会被很快回收，而老一些的对象（如一个应用程序对象）不会被经常骚扰**。**说到底，对象代的设计就是为了优化垃圾回收的过程。**

